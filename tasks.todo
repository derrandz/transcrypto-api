@goals:
  We want to build the signature service so that:
    * We can deploy it as a single service
    * We can deploy it as a collection of nano-services/functions/lambdas
    * We can use each endpoint/function/lambda from the terminal as well
  
  The app has to respect the 12-factor app rules:
    
    I. Codebase:
      One codebase tracked in revision control, many deploys
    
    II. Dependencies:
      Explicitly declare and isolate dependencies
    
    III. Config:
      Store config in the environment

      Outcome:
          * we are going to use a config/app.go which parses the .env values and adds static values if needed
    
    IV. Backing services:
      Treat backing services as attached resources

      Outcome:
        * when Redis and MongoDB are introduced, use docker-compose to be able to spawn locally

    V. Build, release, run:
      Strictly separate build and run stages

      Outcome:
          * define build and run stages in the build system or Makefile
 
    VI. Processes:
      Execute the app as one or more stateless processes
        
      Outcome: 
          * app should be deployable as one stateless process
          * app should be deployable as a multitude of stateless processes
          * app should be open for interaction from cmd as well (i.e: can talk over http and over command-line)
          
    VII. Port binding:
      Export services via port binding
      
      Outcome:
        * define ports on docker-compose, talk to Kubernetes in production

    VIII. Concurrency:
      Scale out via the process model
      
      Outcome:
        * Talk to Kubernetes for that

    IX. Disposability:
      Maximize robustness with fast startup and graceful shutdown
    
    X. Dev/prod parity:
      Keep development, staging, and production as similar as possible
    
    XI. Logs:
      Treat logs as event streams
      
      Outcome:
        * Use Application Level Logging using Middlewares
        * Use Instrumentation Level Logging using Middlewares
    
    XII. Admin processes:
      Run admin/management tasks as one-off processes
        
      Outcome:
        * define a tasks folder for such one-off processes

@iteration-1
  ☐  setup the intial app skeleton
    ✔ cmd for entrypoints @done (11/9/2020, 2:08:32 AM)
    ✔ svc for services definition @done (11/9/2020, 2:08:35 AM)
    ✔ rename shared/service to shared/transport @done (11/9/2020, 2:42:53 AM)
    ☐ redifine services/types.go
      ☐ each service is defining:
        ✔ a service interface @done (11/9/2020, 2:42:56 AM)
        ✔ a transport interface @done (11/9/2020, 2:42:56 AM)
        ☐ a few endpoints
          ☐ each endpoint can define transformers
    ✔ pkg for core functionality as packages @done (11/9/2020, 2:09:27 AM)
  ✔ config for configuration management @done (11/9/2020, 2:43:31 AM)
  ✔ add .env parsing and config management @done (11/9/2020, 2:43:31 AM)
  ✔ add build system or makefile @done (11/8/2020, 8:41:14 PM)
  ✔ add dependency management @done (11/8/2020, 8:41:17 PM)
  ✔ add an http server with a dummy /health endpoint @done (11/9/2020, 2:09:38 AM)
  ☐ add logging
    ✔ add system level logging @done (11/9/2020, 4:57:11 AM)
    ☐ add application level logging
    ☐ add transport level logging
    ☐ add application instrumentation logging (look into having promeutheus)

  ☐ polish http transport
    ☐ add endpoint encoder/decoder
    ☐ add server level json encoder/decoder
    ☐ add endpoints finalizers to be able to write proper headers
    ☐ introduce middlewares
    ☐ fix and clearly define http status codes and response
    ☐ fix and clearly define Http.InTransfomer for requests
    ☐ fix and clearly define Http.OutTransfomer for response
    ☐ add request contexts with timeout
  
  ✔ define an interface for storage and implement it for @done (11/9/2020, 5:36:08 PM)
    ✔ in-memory storage @done (11/9/2020, 5:35:44 PM)


  ☐  add a docker image

  Note: We will try to build this service from scratch and resort to only a small subset of external tooling
@iteration-2
  ☐ define an interface for storage and implement it for
    ☐ redis storage
    ☐ MongoDB storage

  ☐ define isolated functions that can be interfaced with cmd or http or grpc
    ☐ function: get_daemon_pub_key
    ☐ function: store_transactions
    ☐ function: sign_transactions

  ☐ define input and output transformers/serializers for the functions depending on the protocol
    ☐ cmd transformers/serializers: text
    ☐ rest http transformers/serializers: json
    ☐ grpc transformers/serializers: protobuff

  ☐ test the functions in isolation with unit-tests
    ☐ function: get_daemon_pub_key
    ☐ function: store_transactions
    ☐ function: sign_transactions

  ☐ look into adding per-protocol integration tests
    ☐ function: get_daemon_pub_key
      ☐ cmd
      ☐ rest http
      ☐ grpc

    ☐ function: store_transactions
      ☐ cmd
      ☐ rest http
      ☐ grpc
 
    ☐ function: sign_transactions
      ☐ cmd
      ☐ rest http
      ☐ grpc
  
  ☐ look into adding per-protocol e2e tests for functionality
    ☐ service: pubkey
      ☐ cmd
      ☐ rest http
      ☐ grpc

    ☐ service: transactions-storage
      ☐ cmd
      ☐ rest http
      ☐ grpc

    ☐ service: transactions-signature
      ☐ cmd
      ☐ rest http
      ☐ grpc

    ☐ service: signature (all)
      ☐ cmd
      ☐ rest http
      ☐ grpc

@iteration-3
    ☐ look into providing multiple and different http providers
      ☐ gin
      ☐ GorillaMux
      ☐ others..
    ☐ add redis and mongodb to docker-compose
    ☐ add ci/cd using circle-ci or some-other
    ☐ look into deploying into heroku using containers (if it is not hasselous)